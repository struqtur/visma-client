<?php
/**
 * SupplierInvoiceDraftsV2Api
 * PHP version 5
 *
 * @category Class
 * @package  Struqtur\VismaEAccounting
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Visma eAccounting API V2
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Struqtur\VismaEAccounting\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Struqtur\VismaEAccounting\ApiException;
use Struqtur\VismaEAccounting\Configuration;
use Struqtur\VismaEAccounting\HeaderSelector;
use Struqtur\VismaEAccounting\ObjectSerializer;

/**
 * SupplierInvoiceDraftsV2Api Class Doc Comment
 *
 * @category Class
 * @package  Struqtur\VismaEAccounting
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class SupplierInvoiceDraftsV2Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation supplierInvoiceDraftsV2Convert
     *
     * Converts a supplier invoice draft to a supplier invoice
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \Struqtur\VismaEAccounting\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Struqtur\VismaEAccounting\Model\SupplierInvoiceApi
     */
    public function supplierInvoiceDraftsV2Convert($supplier_invoice_draft_id)
    {
        list($response) = $this->supplierInvoiceDraftsV2ConvertWithHttpInfo($supplier_invoice_draft_id);
        return $response;
    }

    /**
     * Operation supplierInvoiceDraftsV2ConvertWithHttpInfo
     *
     * Converts a supplier invoice draft to a supplier invoice
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \Struqtur\VismaEAccounting\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Struqtur\VismaEAccounting\Model\SupplierInvoiceApi, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceDraftsV2ConvertWithHttpInfo($supplier_invoice_draft_id)
    {
        $returnType = '\Struqtur\VismaEAccounting\Model\SupplierInvoiceApi';
        $request = $this->supplierInvoiceDraftsV2ConvertRequest($supplier_invoice_draft_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Struqtur\VismaEAccounting\Model\SupplierInvoiceApi',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceDraftsV2ConvertAsync
     *
     * Converts a supplier invoice draft to a supplier invoice
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDraftsV2ConvertAsync($supplier_invoice_draft_id)
    {
        return $this->supplierInvoiceDraftsV2ConvertAsyncWithHttpInfo($supplier_invoice_draft_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceDraftsV2ConvertAsyncWithHttpInfo
     *
     * Converts a supplier invoice draft to a supplier invoice
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDraftsV2ConvertAsyncWithHttpInfo($supplier_invoice_draft_id)
    {
        $returnType = '\Struqtur\VismaEAccounting\Model\SupplierInvoiceApi';
        $request = $this->supplierInvoiceDraftsV2ConvertRequest($supplier_invoice_draft_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceDraftsV2Convert'
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceDraftsV2ConvertRequest($supplier_invoice_draft_id)
    {
        // verify the required parameter 'supplier_invoice_draft_id' is set
        if ($supplier_invoice_draft_id === null || (is_array($supplier_invoice_draft_id) && count($supplier_invoice_draft_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice_draft_id when calling supplierInvoiceDraftsV2Convert'
            );
        }

        $resourcePath = '/v2/supplierinvoicedrafts/{supplierInvoiceDraftId}/convert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($supplier_invoice_draft_id !== null) {
            $resourcePath = str_replace(
                '{' . 'supplierInvoiceDraftId' . '}',
                ObjectSerializer::toPathValue($supplier_invoice_draft_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceDraftsV2Delete
     *
     * Deletes a supplier invoice draft
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \Struqtur\VismaEAccounting\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function supplierInvoiceDraftsV2Delete($supplier_invoice_draft_id)
    {
        list($response) = $this->supplierInvoiceDraftsV2DeleteWithHttpInfo($supplier_invoice_draft_id);
        return $response;
    }

    /**
     * Operation supplierInvoiceDraftsV2DeleteWithHttpInfo
     *
     * Deletes a supplier invoice draft
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \Struqtur\VismaEAccounting\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceDraftsV2DeleteWithHttpInfo($supplier_invoice_draft_id)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceDraftsV2DeleteRequest($supplier_invoice_draft_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceDraftsV2DeleteAsync
     *
     * Deletes a supplier invoice draft
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDraftsV2DeleteAsync($supplier_invoice_draft_id)
    {
        return $this->supplierInvoiceDraftsV2DeleteAsyncWithHttpInfo($supplier_invoice_draft_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceDraftsV2DeleteAsyncWithHttpInfo
     *
     * Deletes a supplier invoice draft
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDraftsV2DeleteAsyncWithHttpInfo($supplier_invoice_draft_id)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceDraftsV2DeleteRequest($supplier_invoice_draft_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceDraftsV2Delete'
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceDraftsV2DeleteRequest($supplier_invoice_draft_id)
    {
        // verify the required parameter 'supplier_invoice_draft_id' is set
        if ($supplier_invoice_draft_id === null || (is_array($supplier_invoice_draft_id) && count($supplier_invoice_draft_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice_draft_id when calling supplierInvoiceDraftsV2Delete'
            );
        }

        $resourcePath = '/v2/supplierinvoicedrafts/{supplierInvoiceDraftId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($supplier_invoice_draft_id !== null) {
            $resourcePath = str_replace(
                '{' . 'supplierInvoiceDraftId' . '}',
                ObjectSerializer::toPathValue($supplier_invoice_draft_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceDraftsV2Get
     *
     * Get a paginated list of all supplier invoice drafts.
     *
     *
     * @throws \Struqtur\VismaEAccounting\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Struqtur\VismaEAccounting\Model\PaginatedResponseSupplierInvoiceDraftApi
     */
    public function supplierInvoiceDraftsV2Get()
    {
        list($response) = $this->supplierInvoiceDraftsV2GetWithHttpInfo();
        return $response;
    }

    /**
     * Operation supplierInvoiceDraftsV2GetWithHttpInfo
     *
     * Get a paginated list of all supplier invoice drafts.
     *
     *
     * @throws \Struqtur\VismaEAccounting\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Struqtur\VismaEAccounting\Model\PaginatedResponseSupplierInvoiceDraftApi, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceDraftsV2GetWithHttpInfo()
    {
        $returnType = '\Struqtur\VismaEAccounting\Model\PaginatedResponseSupplierInvoiceDraftApi';
        $request = $this->supplierInvoiceDraftsV2GetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Struqtur\VismaEAccounting\Model\PaginatedResponseSupplierInvoiceDraftApi',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceDraftsV2GetAsync
     *
     * Get a paginated list of all supplier invoice drafts.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDraftsV2GetAsync()
    {
        return $this->supplierInvoiceDraftsV2GetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceDraftsV2GetAsyncWithHttpInfo
     *
     * Get a paginated list of all supplier invoice drafts.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDraftsV2GetAsyncWithHttpInfo()
    {
        $returnType = '\Struqtur\VismaEAccounting\Model\PaginatedResponseSupplierInvoiceDraftApi';
        $request = $this->supplierInvoiceDraftsV2GetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceDraftsV2Get'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceDraftsV2GetRequest()
    {

        $resourcePath = '/v2/supplierinvoicedrafts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceDraftsV2Get_0
     *
     * Get a single supplier invoice draft.
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \Struqtur\VismaEAccounting\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi
     */
    public function supplierInvoiceDraftsV2Get_0($supplier_invoice_draft_id)
    {
        list($response) = $this->supplierInvoiceDraftsV2Get_0WithHttpInfo($supplier_invoice_draft_id);
        return $response;
    }

    /**
     * Operation supplierInvoiceDraftsV2Get_0WithHttpInfo
     *
     * Get a single supplier invoice draft.
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \Struqtur\VismaEAccounting\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceDraftsV2Get_0WithHttpInfo($supplier_invoice_draft_id)
    {
        $returnType = '\Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi';
        $request = $this->supplierInvoiceDraftsV2Get_0Request($supplier_invoice_draft_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceDraftsV2Get_0Async
     *
     * Get a single supplier invoice draft.
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDraftsV2Get_0Async($supplier_invoice_draft_id)
    {
        return $this->supplierInvoiceDraftsV2Get_0AsyncWithHttpInfo($supplier_invoice_draft_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceDraftsV2Get_0AsyncWithHttpInfo
     *
     * Get a single supplier invoice draft.
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDraftsV2Get_0AsyncWithHttpInfo($supplier_invoice_draft_id)
    {
        $returnType = '\Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi';
        $request = $this->supplierInvoiceDraftsV2Get_0Request($supplier_invoice_draft_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceDraftsV2Get_0'
     *
     * @param  string $supplier_invoice_draft_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceDraftsV2Get_0Request($supplier_invoice_draft_id)
    {
        // verify the required parameter 'supplier_invoice_draft_id' is set
        if ($supplier_invoice_draft_id === null || (is_array($supplier_invoice_draft_id) && count($supplier_invoice_draft_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice_draft_id when calling supplierInvoiceDraftsV2Get_0'
            );
        }

        $resourcePath = '/v2/supplierinvoicedrafts/{supplierInvoiceDraftId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($supplier_invoice_draft_id !== null) {
            $resourcePath = str_replace(
                '{' . 'supplierInvoiceDraftId' . '}',
                ObjectSerializer::toPathValue($supplier_invoice_draft_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceDraftsV2Post
     *
     * Create a supplier invoice draft.
     *
     * @param  \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi $supplier_invoice_draft  (required)
     * @param  bool $use_default_vat_codes  (optional)
     * @param  bool $calculate_vat_on_cost_accounts Automatic calculation of VAT based on vat code. DK, NL and SE only. If this is set to true, then vat rows will be added based on the vat code of the accounts which can be default or custom based on the \&quot;useDefaultVatCodes\&quot; parameter. (optional)
     * @param  bool $batch_process_extended_validation Validate for batch process and fiscal year. (optional)
     * @param  bool $duplicate_check_extended_validation Check if the invoice is duplicate. (optional)
     *
     * @throws \Struqtur\VismaEAccounting\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi
     */
    public function supplierInvoiceDraftsV2Post($supplier_invoice_draft, $use_default_vat_codes = null, $calculate_vat_on_cost_accounts = null, $batch_process_extended_validation = null, $duplicate_check_extended_validation = null)
    {
        list($response) = $this->supplierInvoiceDraftsV2PostWithHttpInfo($supplier_invoice_draft, $use_default_vat_codes, $calculate_vat_on_cost_accounts, $batch_process_extended_validation, $duplicate_check_extended_validation);
        return $response;
    }

    /**
     * Operation supplierInvoiceDraftsV2PostWithHttpInfo
     *
     * Create a supplier invoice draft.
     *
     * @param  \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi $supplier_invoice_draft  (required)
     * @param  bool $use_default_vat_codes  (optional)
     * @param  bool $calculate_vat_on_cost_accounts Automatic calculation of VAT based on vat code. DK, NL and SE only. If this is set to true, then vat rows will be added based on the vat code of the accounts which can be default or custom based on the \&quot;useDefaultVatCodes\&quot; parameter. (optional)
     * @param  bool $batch_process_extended_validation Validate for batch process and fiscal year. (optional)
     * @param  bool $duplicate_check_extended_validation Check if the invoice is duplicate. (optional)
     *
     * @throws \Struqtur\VismaEAccounting\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceDraftsV2PostWithHttpInfo($supplier_invoice_draft, $use_default_vat_codes = null, $calculate_vat_on_cost_accounts = null, $batch_process_extended_validation = null, $duplicate_check_extended_validation = null)
    {
        $returnType = '\Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi';
        $request = $this->supplierInvoiceDraftsV2PostRequest($supplier_invoice_draft, $use_default_vat_codes, $calculate_vat_on_cost_accounts, $batch_process_extended_validation, $duplicate_check_extended_validation);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceDraftsV2PostAsync
     *
     * Create a supplier invoice draft.
     *
     * @param  \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi $supplier_invoice_draft  (required)
     * @param  bool $use_default_vat_codes  (optional)
     * @param  bool $calculate_vat_on_cost_accounts Automatic calculation of VAT based on vat code. DK, NL and SE only. If this is set to true, then vat rows will be added based on the vat code of the accounts which can be default or custom based on the \&quot;useDefaultVatCodes\&quot; parameter. (optional)
     * @param  bool $batch_process_extended_validation Validate for batch process and fiscal year. (optional)
     * @param  bool $duplicate_check_extended_validation Check if the invoice is duplicate. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDraftsV2PostAsync($supplier_invoice_draft, $use_default_vat_codes = null, $calculate_vat_on_cost_accounts = null, $batch_process_extended_validation = null, $duplicate_check_extended_validation = null)
    {
        return $this->supplierInvoiceDraftsV2PostAsyncWithHttpInfo($supplier_invoice_draft, $use_default_vat_codes, $calculate_vat_on_cost_accounts, $batch_process_extended_validation, $duplicate_check_extended_validation)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceDraftsV2PostAsyncWithHttpInfo
     *
     * Create a supplier invoice draft.
     *
     * @param  \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi $supplier_invoice_draft  (required)
     * @param  bool $use_default_vat_codes  (optional)
     * @param  bool $calculate_vat_on_cost_accounts Automatic calculation of VAT based on vat code. DK, NL and SE only. If this is set to true, then vat rows will be added based on the vat code of the accounts which can be default or custom based on the \&quot;useDefaultVatCodes\&quot; parameter. (optional)
     * @param  bool $batch_process_extended_validation Validate for batch process and fiscal year. (optional)
     * @param  bool $duplicate_check_extended_validation Check if the invoice is duplicate. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDraftsV2PostAsyncWithHttpInfo($supplier_invoice_draft, $use_default_vat_codes = null, $calculate_vat_on_cost_accounts = null, $batch_process_extended_validation = null, $duplicate_check_extended_validation = null)
    {
        $returnType = '\Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi';
        $request = $this->supplierInvoiceDraftsV2PostRequest($supplier_invoice_draft, $use_default_vat_codes, $calculate_vat_on_cost_accounts, $batch_process_extended_validation, $duplicate_check_extended_validation);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceDraftsV2Post'
     *
     * @param  \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi $supplier_invoice_draft  (required)
     * @param  bool $use_default_vat_codes  (optional)
     * @param  bool $calculate_vat_on_cost_accounts Automatic calculation of VAT based on vat code. DK, NL and SE only. If this is set to true, then vat rows will be added based on the vat code of the accounts which can be default or custom based on the \&quot;useDefaultVatCodes\&quot; parameter. (optional)
     * @param  bool $batch_process_extended_validation Validate for batch process and fiscal year. (optional)
     * @param  bool $duplicate_check_extended_validation Check if the invoice is duplicate. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceDraftsV2PostRequest($supplier_invoice_draft, $use_default_vat_codes = null, $calculate_vat_on_cost_accounts = null, $batch_process_extended_validation = null, $duplicate_check_extended_validation = null)
    {
        // verify the required parameter 'supplier_invoice_draft' is set
        if ($supplier_invoice_draft === null || (is_array($supplier_invoice_draft) && count($supplier_invoice_draft) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice_draft when calling supplierInvoiceDraftsV2Post'
            );
        }

        $resourcePath = '/v2/supplierinvoicedrafts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($use_default_vat_codes !== null) {
            $queryParams['useDefaultVatCodes'] = ObjectSerializer::toQueryValue($use_default_vat_codes);
        }
        // query params
        if ($calculate_vat_on_cost_accounts !== null) {
            $queryParams['calculateVatOnCostAccounts'] = ObjectSerializer::toQueryValue($calculate_vat_on_cost_accounts);
        }
        // query params
        if ($batch_process_extended_validation !== null) {
            $queryParams['batchProcessExtendedValidation'] = ObjectSerializer::toQueryValue($batch_process_extended_validation);
        }
        // query params
        if ($duplicate_check_extended_validation !== null) {
            $queryParams['duplicateCheckExtendedValidation'] = ObjectSerializer::toQueryValue($duplicate_check_extended_validation);
        }


        // body params
        $_tempBody = null;
        if (isset($supplier_invoice_draft)) {
            $_tempBody = $supplier_invoice_draft;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceDraftsV2Put
     *
     * Replace content in a supplier invoice draft.
     *
     * @param  string $supplier_invoice_draft_id  (required)
     * @param  \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi $supplier_invoice_draft  (required)
     *
     * @throws \Struqtur\VismaEAccounting\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi
     */
    public function supplierInvoiceDraftsV2Put($supplier_invoice_draft_id, $supplier_invoice_draft)
    {
        list($response) = $this->supplierInvoiceDraftsV2PutWithHttpInfo($supplier_invoice_draft_id, $supplier_invoice_draft);
        return $response;
    }

    /**
     * Operation supplierInvoiceDraftsV2PutWithHttpInfo
     *
     * Replace content in a supplier invoice draft.
     *
     * @param  string $supplier_invoice_draft_id  (required)
     * @param  \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi $supplier_invoice_draft  (required)
     *
     * @throws \Struqtur\VismaEAccounting\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceDraftsV2PutWithHttpInfo($supplier_invoice_draft_id, $supplier_invoice_draft)
    {
        $returnType = '\Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi';
        $request = $this->supplierInvoiceDraftsV2PutRequest($supplier_invoice_draft_id, $supplier_invoice_draft);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceDraftsV2PutAsync
     *
     * Replace content in a supplier invoice draft.
     *
     * @param  string $supplier_invoice_draft_id  (required)
     * @param  \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi $supplier_invoice_draft  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDraftsV2PutAsync($supplier_invoice_draft_id, $supplier_invoice_draft)
    {
        return $this->supplierInvoiceDraftsV2PutAsyncWithHttpInfo($supplier_invoice_draft_id, $supplier_invoice_draft)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceDraftsV2PutAsyncWithHttpInfo
     *
     * Replace content in a supplier invoice draft.
     *
     * @param  string $supplier_invoice_draft_id  (required)
     * @param  \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi $supplier_invoice_draft  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDraftsV2PutAsyncWithHttpInfo($supplier_invoice_draft_id, $supplier_invoice_draft)
    {
        $returnType = '\Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi';
        $request = $this->supplierInvoiceDraftsV2PutRequest($supplier_invoice_draft_id, $supplier_invoice_draft);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceDraftsV2Put'
     *
     * @param  string $supplier_invoice_draft_id  (required)
     * @param  \Struqtur\VismaEAccounting\Model\SupplierInvoiceDraftApi $supplier_invoice_draft  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceDraftsV2PutRequest($supplier_invoice_draft_id, $supplier_invoice_draft)
    {
        // verify the required parameter 'supplier_invoice_draft_id' is set
        if ($supplier_invoice_draft_id === null || (is_array($supplier_invoice_draft_id) && count($supplier_invoice_draft_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice_draft_id when calling supplierInvoiceDraftsV2Put'
            );
        }
        // verify the required parameter 'supplier_invoice_draft' is set
        if ($supplier_invoice_draft === null || (is_array($supplier_invoice_draft) && count($supplier_invoice_draft) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice_draft when calling supplierInvoiceDraftsV2Put'
            );
        }

        $resourcePath = '/v2/supplierinvoicedrafts/{supplierInvoiceDraftId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($supplier_invoice_draft_id !== null) {
            $resourcePath = str_replace(
                '{' . 'supplierInvoiceDraftId' . '}',
                ObjectSerializer::toPathValue($supplier_invoice_draft_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($supplier_invoice_draft)) {
            $_tempBody = $supplier_invoice_draft;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
